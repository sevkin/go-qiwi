// Package wallet provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package wallet

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetByAlias request
	GetByAlias(ctx context.Context, personId int) (*http.Response, error)

	// CreateAccount request  with any body
	CreateAccountWithBody(ctx context.Context, personId int, contentType string, body io.Reader) (*http.Response, error)

	CreateAccount(ctx context.Context, personId int, body CreateAccountJSONRequestBody) (*http.Response, error)

	// GetAccountsOffer request
	GetAccountsOffer(ctx context.Context, personId int) (*http.Response, error)

	// SaveAccountAttributes request  with any body
	SaveAccountAttributesWithBody(ctx context.Context, personId int, accountAlias string, contentType string, body io.Reader) (*http.Response, error)

	SaveAccountAttributes(ctx context.Context, personId int, accountAlias string, body SaveAccountAttributesJSONRequestBody) (*http.Response, error)

	// GetIdentification request
	GetIdentification(ctx context.Context, personId int) (*http.Response, error)

	// PostIdentification request  with any body
	PostIdentificationWithBody(ctx context.Context, personId int, contentType string, body io.Reader) (*http.Response, error)

	PostIdentification(ctx context.Context, personId int, body PostIdentificationJSONRequestBody) (*http.Response, error)

	// GetChequeBytes request
	GetChequeBytes(ctx context.Context, transactionId int, params *GetChequeBytesParams) (*http.Response, error)

	// SendCheque request  with any body
	SendChequeWithBody(ctx context.Context, transactionId int, params *SendChequeParams, contentType string, body io.Reader) (*http.Response, error)

	SendCheque(ctx context.Context, transactionId int, params *SendChequeParams, body SendChequeJSONRequestBody) (*http.Response, error)

	// GetPaymentHistoryByUser request
	GetPaymentHistoryByUser(ctx context.Context, personId int, params *GetPaymentHistoryByUserParams) (*http.Response, error)

	// GetPaymentHistoryTotalByUser request
	GetPaymentHistoryTotalByUser(ctx context.Context, personId int, params *GetPaymentHistoryTotalByUserParams) (*http.Response, error)

	// GetPaymentHistoryByTransaction request
	GetPaymentHistoryByTransaction(ctx context.Context, transactionId int, params *GetPaymentHistoryByTransactionParams) (*http.Response, error)

	// GetPersonProfile request
	GetPersonProfile(ctx context.Context, params *GetPersonProfileParams) (*http.Response, error)

	// GetLimits request
	GetLimits(ctx context.Context, personId int, params *GetLimitsParams) (*http.Response, error)
}

func (c *Client) GetByAlias(ctx context.Context, personId int) (*http.Response, error) {
	req, err := NewGetByAliasRequest(c.Server, personId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountWithBody(ctx context.Context, personId int, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateAccountRequestWithBody(c.Server, personId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccount(ctx context.Context, personId int, body CreateAccountJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateAccountRequest(c.Server, personId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountsOffer(ctx context.Context, personId int) (*http.Response, error) {
	req, err := NewGetAccountsOfferRequest(c.Server, personId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAccountAttributesWithBody(ctx context.Context, personId int, accountAlias string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSaveAccountAttributesRequestWithBody(c.Server, personId, accountAlias, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAccountAttributes(ctx context.Context, personId int, accountAlias string, body SaveAccountAttributesJSONRequestBody) (*http.Response, error) {
	req, err := NewSaveAccountAttributesRequest(c.Server, personId, accountAlias, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentification(ctx context.Context, personId int) (*http.Response, error) {
	req, err := NewGetIdentificationRequest(c.Server, personId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostIdentificationWithBody(ctx context.Context, personId int, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostIdentificationRequestWithBody(c.Server, personId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostIdentification(ctx context.Context, personId int, body PostIdentificationJSONRequestBody) (*http.Response, error) {
	req, err := NewPostIdentificationRequest(c.Server, personId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetChequeBytes(ctx context.Context, transactionId int, params *GetChequeBytesParams) (*http.Response, error) {
	req, err := NewGetChequeBytesRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SendChequeWithBody(ctx context.Context, transactionId int, params *SendChequeParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSendChequeRequestWithBody(c.Server, transactionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SendCheque(ctx context.Context, transactionId int, params *SendChequeParams, body SendChequeJSONRequestBody) (*http.Response, error) {
	req, err := NewSendChequeRequest(c.Server, transactionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentHistoryByUser(ctx context.Context, personId int, params *GetPaymentHistoryByUserParams) (*http.Response, error) {
	req, err := NewGetPaymentHistoryByUserRequest(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentHistoryTotalByUser(ctx context.Context, personId int, params *GetPaymentHistoryTotalByUserParams) (*http.Response, error) {
	req, err := NewGetPaymentHistoryTotalByUserRequest(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentHistoryByTransaction(ctx context.Context, transactionId int, params *GetPaymentHistoryByTransactionParams) (*http.Response, error) {
	req, err := NewGetPaymentHistoryByTransactionRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonProfile(ctx context.Context, params *GetPersonProfileParams) (*http.Response, error) {
	req, err := NewGetPersonProfileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimits(ctx context.Context, personId int, params *GetLimitsParams) (*http.Response, error) {
	req, err := NewGetLimitsRequest(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewGetByAliasRequest generates requests for GetByAlias
func NewGetByAliasRequest(server string, personId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/funding-sources/v2/persons/%s/accounts", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccountRequest calls the generic CreateAccount builder with application/json body
func NewCreateAccountRequest(server string, personId int, body CreateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountRequestWithBody(server, personId, "application/json", bodyReader)
}

// NewCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func NewCreateAccountRequestWithBody(server string, personId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/funding-sources/v2/persons/%s/accounts", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetAccountsOfferRequest generates requests for GetAccountsOffer
func NewGetAccountsOfferRequest(server string, personId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/funding-sources/v2/persons/%s/accounts/offer", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveAccountAttributesRequest calls the generic SaveAccountAttributes builder with application/json body
func NewSaveAccountAttributesRequest(server string, personId int, accountAlias string, body SaveAccountAttributesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveAccountAttributesRequestWithBody(server, personId, accountAlias, "application/json", bodyReader)
}

// NewSaveAccountAttributesRequestWithBody generates requests for SaveAccountAttributes with any type of body
func NewSaveAccountAttributesRequestWithBody(server string, personId int, accountAlias string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "accountAlias", accountAlias)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/funding-sources/v2/persons/%s/accounts/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetIdentificationRequest generates requests for GetIdentification
func NewGetIdentificationRequest(server string, personId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/identification/v1/persons/%s/identification", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostIdentificationRequest calls the generic PostIdentification builder with application/json body
func NewPostIdentificationRequest(server string, personId int, body PostIdentificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostIdentificationRequestWithBody(server, personId, "application/json", bodyReader)
}

// NewPostIdentificationRequestWithBody generates requests for PostIdentification with any type of body
func NewPostIdentificationRequestWithBody(server string, personId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/identification/v1/persons/%s/identification", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetChequeBytesRequest generates requests for GetChequeBytes
func NewGetChequeBytesRequest(server string, transactionId int, params *GetChequeBytesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/payment-history/v1/transactions/%s/cheque/file", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "type", *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "format", *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendChequeRequest calls the generic SendCheque builder with application/json body
func NewSendChequeRequest(server string, transactionId int, params *SendChequeParams, body SendChequeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendChequeRequestWithBody(server, transactionId, params, "application/json", bodyReader)
}

// NewSendChequeRequestWithBody generates requests for SendCheque with any type of body
func NewSendChequeRequestWithBody(server string, transactionId int, params *SendChequeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/payment-history/v1/transactions/%s/cheque/send", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "type", *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetPaymentHistoryByUserRequest generates requests for GetPaymentHistoryByUser
func NewGetPaymentHistoryByUserRequest(server string, personId int, params *GetPaymentHistoryByUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/payment-history/v2/persons/%s/payments", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "rows", params.Rows); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Operation != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "operation", *params.Operation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sources != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sources", *params.Sources); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startDate", *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endDate", *params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextTxnDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "nextTxnDate", *params.NextTxnDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextTxnId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "nextTxnId", *params.NextTxnId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentHistoryTotalByUserRequest generates requests for GetPaymentHistoryTotalByUser
func NewGetPaymentHistoryTotalByUserRequest(server string, personId int, params *GetPaymentHistoryTotalByUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/payment-history/v2/persons/%s/payments/total", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startDate", *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endDate", *params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Operation != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "operation", *params.Operation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sources != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sources", *params.Sources); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentHistoryByTransactionRequest generates requests for GetPaymentHistoryByTransaction
func NewGetPaymentHistoryByTransactionRequest(server string, transactionId int, params *GetPaymentHistoryByTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/payment-history/v2/transactions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "type", *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonProfileRequest generates requests for GetPersonProfile
func NewGetPersonProfileRequest(server string, params *GetPersonProfileParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/person-profile/v1/profile/current")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.AuthInfoEnabled != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "authInfoEnabled", *params.AuthInfoEnabled); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ContractInfoEnabled != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "contractInfoEnabled", *params.ContractInfoEnabled); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserInfoEnabled != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "userInfoEnabled", *params.UserInfoEnabled); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLimitsRequest generates requests for GetLimits
func NewGetLimitsRequest(server string, personId int, params *GetLimitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "personId", personId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/qw-limits/v1/persons/%s/actual-limits", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "types", params.Types); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetByAlias request
	GetByAliasWithResponse(ctx context.Context, personId int) (*GetByAliasResponse, error)

	// CreateAccount request  with any body
	CreateAccountWithBodyWithResponse(ctx context.Context, personId int, contentType string, body io.Reader) (*CreateAccountResponse, error)

	CreateAccountWithResponse(ctx context.Context, personId int, body CreateAccountJSONRequestBody) (*CreateAccountResponse, error)

	// GetAccountsOffer request
	GetAccountsOfferWithResponse(ctx context.Context, personId int) (*GetAccountsOfferResponse, error)

	// SaveAccountAttributes request  with any body
	SaveAccountAttributesWithBodyWithResponse(ctx context.Context, personId int, accountAlias string, contentType string, body io.Reader) (*SaveAccountAttributesResponse, error)

	SaveAccountAttributesWithResponse(ctx context.Context, personId int, accountAlias string, body SaveAccountAttributesJSONRequestBody) (*SaveAccountAttributesResponse, error)

	// GetIdentification request
	GetIdentificationWithResponse(ctx context.Context, personId int) (*GetIdentificationResponse, error)

	// PostIdentification request  with any body
	PostIdentificationWithBodyWithResponse(ctx context.Context, personId int, contentType string, body io.Reader) (*PostIdentificationResponse, error)

	PostIdentificationWithResponse(ctx context.Context, personId int, body PostIdentificationJSONRequestBody) (*PostIdentificationResponse, error)

	// GetChequeBytes request
	GetChequeBytesWithResponse(ctx context.Context, transactionId int, params *GetChequeBytesParams) (*GetChequeBytesResponse, error)

	// SendCheque request  with any body
	SendChequeWithBodyWithResponse(ctx context.Context, transactionId int, params *SendChequeParams, contentType string, body io.Reader) (*SendChequeResponse, error)

	SendChequeWithResponse(ctx context.Context, transactionId int, params *SendChequeParams, body SendChequeJSONRequestBody) (*SendChequeResponse, error)

	// GetPaymentHistoryByUser request
	GetPaymentHistoryByUserWithResponse(ctx context.Context, personId int, params *GetPaymentHistoryByUserParams) (*GetPaymentHistoryByUserResponse, error)

	// GetPaymentHistoryTotalByUser request
	GetPaymentHistoryTotalByUserWithResponse(ctx context.Context, personId int, params *GetPaymentHistoryTotalByUserParams) (*GetPaymentHistoryTotalByUserResponse, error)

	// GetPaymentHistoryByTransaction request
	GetPaymentHistoryByTransactionWithResponse(ctx context.Context, transactionId int, params *GetPaymentHistoryByTransactionParams) (*GetPaymentHistoryByTransactionResponse, error)

	// GetPersonProfile request
	GetPersonProfileWithResponse(ctx context.Context, params *GetPersonProfileParams) (*GetPersonProfileResponse, error)

	// GetLimits request
	GetLimitsWithResponse(ctx context.Context, personId int, params *GetLimitsParams) (*GetLimitsResponse, error)
}

type GetByAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Accounts
}

// Status returns HTTPResponse.Status
func (r GetByAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsOfferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsOffer
}

// Status returns HTTPResponse.Status
func (r GetAccountsOfferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsOfferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveAccountAttributesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SaveAccountAttributesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveAccountAttributesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Identification
}

// Status returns HTTPResponse.Status
func (r GetIdentificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostIdentificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Identification
}

// Status returns HTTPResponse.Status
func (r PostIdentificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostIdentificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChequeBytesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetChequeBytesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChequeBytesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendChequeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendChequeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendChequeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentHistoryByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payments
}

// Status returns HTTPResponse.Status
func (r GetPaymentHistoryByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentHistoryByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentHistoryTotalByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentsTotal
}

// Status returns HTTPResponse.Status
func (r GetPaymentHistoryTotalByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentHistoryTotalByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentHistoryByTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
}

// Status returns HTTPResponse.Status
func (r GetPaymentHistoryByTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentHistoryByTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonProfile
}

// Status returns HTTPResponse.Status
func (r GetPersonProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Limits
}

// Status returns HTTPResponse.Status
func (r GetLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetByAliasWithResponse request returning *GetByAliasResponse
func (c *ClientWithResponses) GetByAliasWithResponse(ctx context.Context, personId int) (*GetByAliasResponse, error) {
	rsp, err := c.GetByAlias(ctx, personId)
	if err != nil {
		return nil, err
	}
	return ParseGetByAliasResponse(rsp)
}

// CreateAccountWithBodyWithResponse request with arbitrary body returning *CreateAccountResponse
func (c *ClientWithResponses) CreateAccountWithBodyWithResponse(ctx context.Context, personId int, contentType string, body io.Reader) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccountWithBody(ctx, personId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountWithResponse(ctx context.Context, personId int, body CreateAccountJSONRequestBody) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccount(ctx, personId, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

// GetAccountsOfferWithResponse request returning *GetAccountsOfferResponse
func (c *ClientWithResponses) GetAccountsOfferWithResponse(ctx context.Context, personId int) (*GetAccountsOfferResponse, error) {
	rsp, err := c.GetAccountsOffer(ctx, personId)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsOfferResponse(rsp)
}

// SaveAccountAttributesWithBodyWithResponse request with arbitrary body returning *SaveAccountAttributesResponse
func (c *ClientWithResponses) SaveAccountAttributesWithBodyWithResponse(ctx context.Context, personId int, accountAlias string, contentType string, body io.Reader) (*SaveAccountAttributesResponse, error) {
	rsp, err := c.SaveAccountAttributesWithBody(ctx, personId, accountAlias, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSaveAccountAttributesResponse(rsp)
}

func (c *ClientWithResponses) SaveAccountAttributesWithResponse(ctx context.Context, personId int, accountAlias string, body SaveAccountAttributesJSONRequestBody) (*SaveAccountAttributesResponse, error) {
	rsp, err := c.SaveAccountAttributes(ctx, personId, accountAlias, body)
	if err != nil {
		return nil, err
	}
	return ParseSaveAccountAttributesResponse(rsp)
}

// GetIdentificationWithResponse request returning *GetIdentificationResponse
func (c *ClientWithResponses) GetIdentificationWithResponse(ctx context.Context, personId int) (*GetIdentificationResponse, error) {
	rsp, err := c.GetIdentification(ctx, personId)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentificationResponse(rsp)
}

// PostIdentificationWithBodyWithResponse request with arbitrary body returning *PostIdentificationResponse
func (c *ClientWithResponses) PostIdentificationWithBodyWithResponse(ctx context.Context, personId int, contentType string, body io.Reader) (*PostIdentificationResponse, error) {
	rsp, err := c.PostIdentificationWithBody(ctx, personId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostIdentificationResponse(rsp)
}

func (c *ClientWithResponses) PostIdentificationWithResponse(ctx context.Context, personId int, body PostIdentificationJSONRequestBody) (*PostIdentificationResponse, error) {
	rsp, err := c.PostIdentification(ctx, personId, body)
	if err != nil {
		return nil, err
	}
	return ParsePostIdentificationResponse(rsp)
}

// GetChequeBytesWithResponse request returning *GetChequeBytesResponse
func (c *ClientWithResponses) GetChequeBytesWithResponse(ctx context.Context, transactionId int, params *GetChequeBytesParams) (*GetChequeBytesResponse, error) {
	rsp, err := c.GetChequeBytes(ctx, transactionId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetChequeBytesResponse(rsp)
}

// SendChequeWithBodyWithResponse request with arbitrary body returning *SendChequeResponse
func (c *ClientWithResponses) SendChequeWithBodyWithResponse(ctx context.Context, transactionId int, params *SendChequeParams, contentType string, body io.Reader) (*SendChequeResponse, error) {
	rsp, err := c.SendChequeWithBody(ctx, transactionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSendChequeResponse(rsp)
}

func (c *ClientWithResponses) SendChequeWithResponse(ctx context.Context, transactionId int, params *SendChequeParams, body SendChequeJSONRequestBody) (*SendChequeResponse, error) {
	rsp, err := c.SendCheque(ctx, transactionId, params, body)
	if err != nil {
		return nil, err
	}
	return ParseSendChequeResponse(rsp)
}

// GetPaymentHistoryByUserWithResponse request returning *GetPaymentHistoryByUserResponse
func (c *ClientWithResponses) GetPaymentHistoryByUserWithResponse(ctx context.Context, personId int, params *GetPaymentHistoryByUserParams) (*GetPaymentHistoryByUserResponse, error) {
	rsp, err := c.GetPaymentHistoryByUser(ctx, personId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentHistoryByUserResponse(rsp)
}

// GetPaymentHistoryTotalByUserWithResponse request returning *GetPaymentHistoryTotalByUserResponse
func (c *ClientWithResponses) GetPaymentHistoryTotalByUserWithResponse(ctx context.Context, personId int, params *GetPaymentHistoryTotalByUserParams) (*GetPaymentHistoryTotalByUserResponse, error) {
	rsp, err := c.GetPaymentHistoryTotalByUser(ctx, personId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentHistoryTotalByUserResponse(rsp)
}

// GetPaymentHistoryByTransactionWithResponse request returning *GetPaymentHistoryByTransactionResponse
func (c *ClientWithResponses) GetPaymentHistoryByTransactionWithResponse(ctx context.Context, transactionId int, params *GetPaymentHistoryByTransactionParams) (*GetPaymentHistoryByTransactionResponse, error) {
	rsp, err := c.GetPaymentHistoryByTransaction(ctx, transactionId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentHistoryByTransactionResponse(rsp)
}

// GetPersonProfileWithResponse request returning *GetPersonProfileResponse
func (c *ClientWithResponses) GetPersonProfileWithResponse(ctx context.Context, params *GetPersonProfileParams) (*GetPersonProfileResponse, error) {
	rsp, err := c.GetPersonProfile(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonProfileResponse(rsp)
}

// GetLimitsWithResponse request returning *GetLimitsResponse
func (c *ClientWithResponses) GetLimitsWithResponse(ctx context.Context, personId int, params *GetLimitsParams) (*GetLimitsResponse, error) {
	rsp, err := c.GetLimits(ctx, personId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitsResponse(rsp)
}

// ParseGetByAliasResponse parses an HTTP response from a GetByAliasWithResponse call
func ParseGetByAliasResponse(rsp *http.Response) (*GetByAliasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Accounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAccountResponse parses an HTTP response from a CreateAccountWithResponse call
func ParseCreateAccountResponse(rsp *http.Response) (*CreateAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetAccountsOfferResponse parses an HTTP response from a GetAccountsOfferWithResponse call
func ParseGetAccountsOfferResponse(rsp *http.Response) (*GetAccountsOfferResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsOfferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsOffer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveAccountAttributesResponse parses an HTTP response from a SaveAccountAttributesWithResponse call
func ParseSaveAccountAttributesResponse(rsp *http.Response) (*SaveAccountAttributesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SaveAccountAttributesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetIdentificationResponse parses an HTTP response from a GetIdentificationWithResponse call
func ParseGetIdentificationResponse(rsp *http.Response) (*GetIdentificationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetIdentificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Identification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostIdentificationResponse parses an HTTP response from a PostIdentificationWithResponse call
func ParsePostIdentificationResponse(rsp *http.Response) (*PostIdentificationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostIdentificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Identification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChequeBytesResponse parses an HTTP response from a GetChequeBytesWithResponse call
func ParseGetChequeBytesResponse(rsp *http.Response) (*GetChequeBytesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetChequeBytesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendChequeResponse parses an HTTP response from a SendChequeWithResponse call
func ParseSendChequeResponse(rsp *http.Response) (*SendChequeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SendChequeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetPaymentHistoryByUserResponse parses an HTTP response from a GetPaymentHistoryByUserWithResponse call
func ParseGetPaymentHistoryByUserResponse(rsp *http.Response) (*GetPaymentHistoryByUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentHistoryByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payments
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPaymentHistoryTotalByUserResponse parses an HTTP response from a GetPaymentHistoryTotalByUserWithResponse call
func ParseGetPaymentHistoryTotalByUserResponse(rsp *http.Response) (*GetPaymentHistoryTotalByUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentHistoryTotalByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentsTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPaymentHistoryByTransactionResponse parses an HTTP response from a GetPaymentHistoryByTransactionWithResponse call
func ParseGetPaymentHistoryByTransactionResponse(rsp *http.Response) (*GetPaymentHistoryByTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentHistoryByTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonProfileResponse parses an HTTP response from a GetPersonProfileWithResponse call
func ParseGetPersonProfileResponse(rsp *http.Response) (*GetPersonProfileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPersonProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLimitsResponse parses an HTTP response from a GetLimitsWithResponse call
func ParseGetLimitsResponse(rsp *http.Response) (*GetLimitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Limits
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

